generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
}

model Business {
  id                 String               @id @db.Uuid
  name               String
  owner_user_id      String

  // Optional Business Profile metadata (Settings)
  address                  String?
  phone                    String?
  logo_url                 String?
  logo_upload_id           String?              @db.Uuid
  industry                 String?
  currency                 String               @default("USD")
  timezone                 String               @default("America/Chicago")
  fiscal_year_start_month  Int                  @default(1)

  // Phase 7.1: per-business authz mode flag (default OFF)
  authz_mode         String               @default("OFF")
  // Phase 7.2: enforcement wave gate (0=none, 1=Team+RolePolicy, 2=Reconcile, 3=Snapshots/Exports)
  authz_enforce_wave Int                  @default(0)
  created_at         DateTime             @default(now()) @db.Timestamptz(6)
  accounts           Account[]
  entries            Entry[]
  roles              UserBusinessRole[]
  uploads            Upload[]
  bankConnections    BankConnection[]
  bankTransactions   BankTransaction[]
  bankMatches        BankMatch[]
  reconcileSnapshots ReconcileSnapshot[]
  invites            BusinessInvite[]
  categories         Category[]
  rolePolicies       BusinessRolePolicy[]
  transfers          Transfer[]
  activityLogs       ActivityLog[]
  closedPeriods      ClosedPeriod[]
  vendors            Vendor[]

  budgets Budget[]
  goals   Goal[]

  @@index([owner_user_id], map: "idx_business_owner_user_id")
  @@map("business")
}

model UserBusinessRole {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String   @db.Uuid
  user_id     String

  // Best-effort email for display. Filled on invite accept and backfilled for the current user on team fetch.
  email       String?

  role        String
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, user_id])
  @@index([user_id], map: "idx_ubr_user_id")
  @@index([business_id, role], map: "idx_ubr_business_role")
  @@map("user_business_role")
}

model Account {
  id                    String              @id @db.Uuid
  business_id           String              @db.Uuid
  name                  String
  type                  String
  opening_balance_cents BigInt
  opening_balance_date  DateTime            @db.Timestamptz(6)

  // Manual metadata (non-Plaid accounts OR pre-connect storage)
  currency_code         String?             @db.VarChar(3)
  institution_name      String?
  last4                 String?             @db.VarChar(8)

  archived_at           DateTime?           @db.Timestamptz(6)
  created_at            DateTime            @default(now()) @db.Timestamptz(6)
  updated_at            DateTime            @default(now()) @db.Timestamptz(6)
  business              Business            @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  entries               Entry[]
  uploads               Upload[]
  bankConnections       BankConnection[]
  bankTransactions      BankTransaction[]
  bankMatches           BankMatch[]
  reconcileSnapshots    ReconcileSnapshot[]

  @@index([business_id, archived_at], map: "idx_account_business_archived")
  @@index([business_id, name], map: "idx_account_business_name")
  @@map("account")
}

model Entry {
  id           String   @id @db.Uuid
  business_id  String   @db.Uuid
  account_id   String   @db.Uuid
  date         DateTime @db.Date
  payee        String?
  memo         String?
  amount_cents BigInt
  type         String
  method       String?
  category_id  String?  @db.Uuid
  vendor_id    String?  @db.Uuid
  vendor       Vendor?  @relation(fields: [vendor_id], references: [id])

  transfer_id String? @db.Uuid

  // Durable uploadâ†’entry linkage (one upload creates at most one entry)
  sourceUploadId String? @map("source_upload_id") @db.Uuid

  // Transfers
  transfer Transfer? @relation("TransferEntries", fields: [transfer_id], references: [id], onDelete: SetNull, onUpdate: NoAction)

  // Category System v2
  category Category? @relation(fields: [category_id], references: [id], onDelete: SetNull, onUpdate: NoAction)

  status     String    @default("EXPECTED")
  deleted_at DateTime? @db.Timestamptz(6)

  // Phase 4D: ledger-only adjustment (reversible later)
  is_adjustment       Boolean   @default(false)
  adjusted_at         DateTime? @db.Timestamptz(6)
  adjusted_by_user_id String?   @db.Uuid
  adjustment_reason   String?

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)
  account    Account  @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  business   Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  bankMatches BankMatch[]

  @@unique([business_id, sourceUploadId], map: "u_entry_scope_source_upload")
  @@index([business_id, account_id, date, created_at], map: "idx_entry_business_account_date_created")
  @@index([business_id, account_id, deleted_at], map: "idx_entry_business_account_deleted")
  @@index([business_id, category_id], map: "idx_entry_business_category")
  @@map("entry")
}

model Category {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String    @db.Uuid
  name        String
  archived_at DateTime? @db.Timestamptz(6)

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  entries  Entry[]

  budgets Budget[]
  goals   Goal[]

  @@unique([business_id, name], map: "u_category_business_name")
  @@index([business_id, archived_at], map: "i_category_business_archived")
  @@map("category")
}

model EntryIssue {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String    @db.Uuid
  account_id  String    @db.Uuid
  entry_id    String    @db.Uuid
  issue_type  String
  status      String    @default("OPEN")
  severity    String    @default("WARNING")
  group_key   String?
  details     String
  detected_at DateTime  @default(now()) @db.Timestamptz(6)
  resolved_at DateTime? @db.Timestamptz(6)
  created_at  DateTime  @default(now()) @db.Timestamptz(6)
  updated_at  DateTime  @default(now()) @db.Timestamptz(6)

  @@unique([business_id, account_id, entry_id, issue_type], name: "u_entry_issues_scope", map: "u_entry_issues_scope")
  @@index([business_id, account_id, status], map: "i_entry_issues_scope_status")
  @@index([business_id, account_id, issue_type], map: "i_entry_issues_scope_type")
  @@map("entry_issues")
}

model Upload {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id        String    @db.Uuid
  account_id         String?   @db.Uuid
  upload_type        String
  s3_bucket          String
  s3_key             String
  original_filename  String
  content_type       String
  size_bytes         BigInt
  status             String    @default("INITIATED")
  created_by_user_id String
  meta               Json?
  created_at         DateTime  @default(now()) @db.Timestamptz(6)
  completed_at       DateTime? @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account  Account? @relation(fields: [account_id], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@index([business_id, created_at], map: "idx_upload_business_created")
  @@index([business_id, account_id, created_at], map: "idx_upload_business_account_created")
  @@index([business_id, upload_type, status], map: "idx_upload_business_type_status")
  @@map("upload")
}

model BankConnection {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid
  account_id  String @db.Uuid

  plaid_item_id           String
  plaid_account_id        String
  access_token_ciphertext String

  effective_start_date DateTime @db.Date

  sync_cursor  String?
  last_sync_at DateTime? @db.Timestamptz(6)

  has_new_transactions Boolean @default(false)

  last_known_balance_cents BigInt?
  last_known_balance_at    DateTime? @db.Timestamptz(6)

  opening_adjustment_created_at DateTime? @db.Timestamptz(6)

  // Opening handling
  opening_policy String @default("AUTO") // AUTO | MANUAL (manual means never create/overwrite opening)

  // If user chooses "Keep manual opening", store Plaid suggestion here (for reference + explicit apply later)
  suggested_opening_cents BigInt?
  suggested_opening_date  DateTime? @db.Date
  suggested_balance_cents BigInt?
  suggested_balance_at    DateTime? @db.Timestamptz(6)

  institution_name String?
  institution_id   String?
  plaid_mask       String? @db.VarChar(8)
  status           String  @default("CONNECTED")
  error_code       String?
  error_message    String?

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account  Account  @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, account_id], map: "u_bank_connection_scope_account")
  @@unique([business_id, plaid_account_id], map: "u_bank_connection_scope_plaid_account")
  @@index([business_id, status], map: "i_bank_connection_scope_status")
  @@map("bank_connection")
}

model BankTransaction {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid
  account_id  String @db.Uuid

  plaid_transaction_id String?
  plaid_account_id     String?

  // Source tracking (Phase 4C CSV import)
  source           String? // "PLAID" | "CSV" (PLAID rows may leave null)
  source_upload_id String? @db.Uuid
  source_parser    String? // e.g. "BANK_OF_AMERICA"
  import_hash      String? // sha256 for idempotent CSV import

  posted_date DateTime @db.Date

  authorized_date   DateTime? @db.Date
  amount_cents      BigInt
  name              String
  is_pending        Boolean   @default(false)
  iso_currency_code String?

  is_removed Boolean   @default(false)
  removed_at DateTime? @db.Timestamptz(6)

  raw Json?

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account  Account  @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, plaid_transaction_id], map: "u_bank_txn_scope_plaid_txn")
  @@unique([business_id, account_id, source, import_hash], map: "u_bank_txn_csv_dedupe")
  @@index([business_id, account_id, posted_date, created_at], map: "i_bank_txn_scope_account_posted_created")
  @@index([business_id, account_id, is_removed, is_pending], map: "i_bank_txn_scope_flags")
  @@map("bank_transaction")
}

model BankMatch {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid
  account_id  String @db.Uuid

  bank_transaction_id String @db.Uuid
  entry_id            String @db.Uuid

  match_type           String // FULL | PARTIAL
  matched_amount_cents BigInt // stored WITH SIGN

  created_by_user_id String
  created_at         DateTime @default(now()) @db.Timestamptz(6)

  voided_at         DateTime? @db.Timestamptz(6)
  voided_by_user_id String?

  // Relations
  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account  Account  @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  entry    Entry    @relation(fields: [entry_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([business_id, account_id, bank_transaction_id], map: "i_bank_match_bank_txn")
  @@index([business_id, account_id, entry_id], map: "i_bank_match_entry")
  @@index([business_id, account_id, voided_at], map: "i_bank_match_voided")
  @@map("bank_match")
}

model Transfer {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id     String   @db.Uuid
  from_account_id String   @db.Uuid
  to_account_id   String   @db.Uuid
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  // Entry legs link via Entry.transfer_id
  entries Entry[] @relation("TransferEntries")

  @@index([business_id, from_account_id], map: "i_transfer_business_from")
  @@index([business_id, to_account_id], map: "i_transfer_business_to")
  @@map("transfer")
}

model ReconcileSnapshot {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid
  account_id  String @db.Uuid
  month       String // YYYY-MM

  created_at         DateTime @default(now()) @db.Timestamptz(6)
  created_by_user_id String

  // Summary counts
  bank_unmatched_count   Int @default(0)
  bank_partial_count     Int @default(0)
  bank_matched_count     Int @default(0)
  entries_expected_count Int @default(0)
  entries_matched_count  Int @default(0)
  revert_count           Int @default(0)

  // Totals
  remaining_abs_cents BigInt @default(0)

  // Export artifacts (S3 pointers)
  bank_csv_s3_key    String
  matches_csv_s3_key String
  audit_csv_s3_key   String

  // Optional integrity hashes
  bank_csv_sha256    String?
  matches_csv_sha256 String?
  audit_csv_sha256   String?

  // Relations
  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account  Account  @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, account_id, month], map: "u_reconcile_snapshot_scope_month")
  @@index([business_id, account_id, created_at(sort: Desc)], map: "i_reconcile_snapshot_scope_created")
  @@map("reconcile_snapshot")
}

model BusinessInvite {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid

  // Normalized lowercase email
  email String

  // Strict allowlist role (enforced in handler)
  role String

  // Unique accept token
  token String @unique

  created_at         DateTime @default(now()) @db.Timestamptz(6)
  created_by_user_id String

  expires_at DateTime @db.Timestamptz(6)

  accepted_at         DateTime? @db.Timestamptz(6)
  accepted_by_user_id String?

  // Idempotent revoke (no delete)
  revoked_at         DateTime? @db.Timestamptz(6)
  revoked_by_user_id String?

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([business_id, created_at(sort: Desc)], map: "i_business_invite_scope_created")
  @@index([business_id, email], map: "i_business_invite_scope_email")
  @@map("business_invite")
}

model BusinessRolePolicy {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid

  // Strict allowlist role string enforced in handler (OWNER/ADMIN/BOOKKEEPER/ACCOUNTANT/MEMBER)
  role String

  // Store-only policy (NOT enforced yet)
  policy_json Json

  updated_at         DateTime @default(now()) @db.Timestamptz(6)
  updated_by_user_id String

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, role], map: "u_business_role_policy_scope_role")
  @@index([business_id, updated_at(sort: Desc)], map: "i_business_role_policy_scope_updated")
  @@map("business_role_policy")
}

model ActivityLog {
  id               String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id      String  @db.Uuid
  scope_account_id String? @db.Uuid

  event_type    String
  actor_user_id String
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  payload_json  Json

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([business_id, created_at(sort: Desc)], map: "i_activity_log_scope_created")
  @@index([business_id, scope_account_id, created_at(sort: Desc)], map: "i_activity_log_scope_account_created")
  @@map("activity_log")
}

model ClosedPeriod {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id       String   @db.Uuid
  month             String // YYYY-MM
  closed_at         DateTime @default(now()) @db.Timestamptz(6)
  closed_by_user_id String

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, month], map: "u_closed_period_scope_month")
  @@index([business_id, month], map: "i_closed_period_scope_month")
  @@map("closed_period")
}

model Vendor {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String   @db.Uuid
  name        String
  notes       String?
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  // Opposite side of Entry.vendor relation
  entries Entry[]

  @@unique([business_id, name], map: "u_vendor_scope_name")
  @@index([business_id, updated_at(sort: Desc)], map: "i_vendor_scope_updated_desc")
  @@map("vendor")
}

model Budget {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid
  month       String // YYYY-MM
  category_id String @db.Uuid

  // Stored as positive cents (budget target)
  budget_cents BigInt

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @db.Timestamptz(6)

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  category Category @relation(fields: [category_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([business_id, month, category_id], map: "u_budget_scope_month_category")
  @@index([business_id, month], map: "i_budget_scope_month")
  @@index([business_id, category_id], map: "i_budget_scope_category")
  @@map("budget")
}

model Goal {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  business_id String @db.Uuid

  name        String
  category_id String  @db.Uuid // required (category-driven)
  month_start String // YYYY-MM (start month anchor for v1)
  month_end   String? // YYYY-MM optional

  // Stored as positive cents (target)
  target_cents BigInt

  status String @default("ACTIVE") // ACTIVE | PAUSED | ARCHIVED

  created_at         DateTime @default(now()) @db.Timestamptz(6)
  updated_at         DateTime @default(now()) @db.Timestamptz(6)
  created_by_user_id String

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  category Category @relation(fields: [category_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([business_id, status], map: "i_goal_scope_status")
  @@index([business_id, category_id], map: "i_goal_scope_category")
  @@map("goal")
}
