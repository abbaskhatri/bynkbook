"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { getCurrentUser } from "aws-amplify/auth";
import { useMutation, useQueryClient } from "@tanstack/react-query";

import { useBusinesses } from "@/lib/queries/useBusinesses";
import { useAccounts } from "@/lib/queries/useAccounts";
import { useEntries } from "@/lib/queries/useEntries";
import { useLedgerSummary } from "@/lib/queries/useLedgerSummary";
import { createEntry, deleteEntry, type Entry } from "@/lib/api/entries";
import { metrics } from "@/lib/perf/metrics";

import { PageHeader } from "@/components/app/page-header";
import { CapsuleSelect } from "@/components/app/capsule-select";
import { FilterBar } from "@/components/app/filter-bar";
import { LedgerTableShell } from "@/components/ledger/ledger-table-shell";
import { TotalsFooter } from "@/components/ledger/totals-footer";

import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

// ---------- helpers ----------
function todayYmd() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}
function monthStartYmd() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  return `${yyyy}-${mm}-01`;
}
function toBigIntSafe(v: unknown): bigint {
  try {
    if (typeof v === "bigint") return v;
    if (typeof v === "number") return BigInt(Math.trunc(v));
    if (typeof v === "string" && v.trim() !== "") return BigInt(v);
  } catch {}
  return 0n;
}
function formatUsdFromCents(cents: bigint) {
  const neg = cents < 0n;
  const abs = neg ? -cents : cents;
  const dollars = abs / 100n;
  const pennies = abs % 100n;
  const withCommas = dollars.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  const core = `${withCommas}.${pennies.toString().padStart(2, "0")}`;
  return neg ? `(${core})` : core;
}
// Accepts: 1000, 1,000.50, -1000.50, (1000.50), $1,000.50
function parseMoneyToCents(input: string): number {
  const raw = (input || "").trim();
  if (!raw) return 0;

  const parenNeg = raw.startsWith("(") && raw.endsWith(")");
  const cleaned0 = raw.replace(/^\(|\)$/g, "").replace(/[\$,]/g, "").trim();
  if (!cleaned0) return 0;

  const m = cleaned0.match(/^(-)?(\d+)(?:\.(\d{0,2}))?$/);
  if (!m) return 0;

  const neg = parenNeg || !!m[1];
  const dollars = Number(m[2] || "0");
  const centsPart = (m[3] || "").padEnd(2, "0").slice(0, 2);
  const cents = Number(centsPart || "0");
  const total = dollars * 100 + cents;
  return neg ? -total : total;
}

function sortEntriesDisplayDesc(a: Entry, b: Entry) {
  if (a.date !== b.date) return a.date < b.date ? 1 : -1;
  const ca = a.created_at || "";
  const cb = b.created_at || "";
  if (ca === cb) return 0;
  return ca < cb ? 1 : -1;
}
function sortEntriesChronAsc(a: Entry, b: Entry) {
  if (a.date !== b.date) return a.date < b.date ? -1 : 1;
  const ca = a.created_at || "";
  const cb = b.created_at || "";
  if (ca === cb) return 0;
  return ca < cb ? -1 : 1;
}
function titleCase(s: string) {
  const t = (s || "").trim().toLowerCase();
  if (!t) return "";
  return t.replace(/\b\w/g, (c) => c.toUpperCase());
}

// ---------- Payee/Category styled suggestions (matches dropdown look) ----------
function filterOptions(query: string, options: string[]) {
  const q = query.trim().toLowerCase();
  if (!q) return options.slice(0, 8);
  const starts = options.filter((o) => o.toLowerCase().startsWith(q));
  const contains = options.filter(
    (o) => !o.toLowerCase().startsWith(q) && o.toLowerCase().includes(q)
  );
  return [...starts, ...contains].slice(0, 8);
}

function AutoInput(props: {
  value: string;
  onValueChange: (v: string) => void;
  options: string[];
  placeholder?: string;
  inputClassName?: string;
  onSubmit?: () => void;
  inputRef?: React.RefObject<HTMLInputElement>;
  onAnyChange?: () => void;
}) {
  const { value, onValueChange, options, placeholder, inputClassName, onSubmit, inputRef, onAnyChange } =
    props;

  const [open, setOpen] = useState(false);
  const [active, setActive] = useState(0);

  const filtered = useMemo(() => filterOptions(value, options), [value, options]);

  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "ArrowDown" || e.key === "ArrowUp") {
      e.preventDefault();
      if (!open) setOpen(true);
      setActive((prev) => {
        const max = Math.max(0, filtered.length - 1);
        if (e.key === "ArrowDown") return Math.min(max, prev + 1);
        return Math.max(0, prev - 1);
      });
      return;
    }

    if (e.key === "Enter") {
      if (open && filtered[active]) {
        e.preventDefault();
        onValueChange(filtered[active]);
        onAnyChange?.();
        setOpen(false);
        return;
      }
      if (onSubmit) {
        e.preventDefault();
        onSubmit();
      }
      return;
    }

    if (e.key === "Escape") {
      setOpen(false);
      return;
    }

    // typing opens (keyboard-driven)
    if (e.key.length === 1) {
      setOpen(true);
      setActive(0);
    }
  };

  return (
    <div className="relative">
      <input
        ref={inputRef as any}
        className={inputClassName}
        placeholder={placeholder}
        value={value}
        onChange={(e) => {
          onValueChange(e.target.value);
          onAnyChange?.();
          setActive(0);
        }}
        onKeyDown={onKeyDown}
        onBlur={() => setTimeout(() => setOpen(false), 120)}
      />

      {open && filtered.length > 0 ? (
        <div className="absolute left-0 top-full mt-1 w-full z-50 rounded-md border bg-white shadow-md p-1">
          {filtered.map((opt, idx) => (
            <button
              key={opt}
              type="button"
              className={
                "w-full text-left text-xs px-2 py-1.5 rounded-sm " +
                (idx === active ? "bg-slate-100" : "bg-white") +
                " hover:bg-slate-100"
              }
              onMouseDown={(e) => {
                e.preventDefault();
                onValueChange(opt);
                onAnyChange?.();
                setOpen(false);
              }}
            >
              {opt}
            </button>
          ))}
        </div>
      ) : null}
    </div>
  );
}

// ---------- Types ----------
type UiType = "INCOME" | "EXPENSE" | "TRANSFER" | "ADJUSTMENT";
type UiMethod =
  | "CASH"
  | "CARD"
  | "ACH"
  | "WIRE"
  | "CHECK"
  | "DIRECT_DEPOSIT"
  | "ZELLE"
  | "TRANSFER"
  | "OTHER";

function normalizeBackendType(uiType: UiType): "INCOME" | "EXPENSE" {
  if (uiType === "INCOME") return "INCOME";
  return "EXPENSE";
}
function normalizeBackendMethod(uiMethod: UiMethod): string {
  if (uiMethod === "CASH") return "CASH";
  if (uiMethod === "CARD") return "CARD";
  if (uiMethod === "CHECK") return "CHECK";
  if (uiMethod === "ACH") return "ACH";
  if (uiMethod === "WIRE") return "WIRE";
  return "OTHER";
}

type CreateVars = {
  tempId: string;
  date: string;
  ref: string;
  payee: string;
  type: UiType;
  method: UiMethod;
  category: string;
  amountStr: string;
};

export default function LedgerPage() {
  const router = useRouter();
  const sp = useSearchParams();
  const qc = useQueryClient();
  const containerStyle = { height: "calc(100vh - 56px - 48px)" as const };

  const [authReady, setAuthReady] = useState(false);
  useEffect(() => {
    (async () => {
      try { await getCurrentUser(); setAuthReady(true); } catch { router.replace("/login"); }
    })();
  }, [router]);

  const businessesQ = useBusinesses();
  const bizIdFromUrl = sp.get("businessId") ?? sp.get("businessesId");
  const accountIdFromUrl = sp.get("accountId");

  const selectedBusinessId = useMemo(() => {
    const list = businessesQ.data ?? [];
    if (bizIdFromUrl) return bizIdFromUrl;
    return list[0]?.id ?? null;
  }, [bizIdFromUrl, businessesQ.data]);

  const accountsQ = useAccounts(selectedBusinessId);

  const selectedAccountId = useMemo(() => {
    const list = accountsQ.data ?? [];
    if (accountIdFromUrl) return accountIdFromUrl;
    return list.find((a) => !a.archived_at)?.id ?? "";
  }, [accountsQ.data, accountIdFromUrl]);

  const selectedAccount = useMemo(() => {
    const list = accountsQ.data ?? [];
    return list.find((a) => a.id === selectedAccountId) ?? null;
  }, [accountsQ.data, selectedAccountId]);

  const [rowsPerPage, setRowsPerPage] = useState(100);
  const [page, setPage] = useState(1);
  const maxFetch = 500;
  const fetchLimit = useMemo(() => Math.min(maxFetch, rowsPerPage * page), [rowsPerPage, page]);

  const entriesKey = useMemo(
    () => ["entries", selectedBusinessId, selectedAccountId, fetchLimit] as const,
    [selectedBusinessId, selectedAccountId, fetchLimit]
  );

  const entriesQ = useEntries({ businessId: selectedBusinessId, accountId: selectedAccountId, limit: fetchLimit });

  const from = monthStartYmd();
  const to = todayYmd();
  const summaryQ = useLedgerSummary({ businessId: selectedBusinessId, accountId: selectedAccountId, from, to });

  // opening balance row
  const openingBalanceCents = useMemo(() => BigInt(Number(selectedAccount?.opening_balance_cents ?? 0)), [selectedAccount]);

  const openingEntry: Entry | null = useMemo(() => {
    if (!selectedBusinessId || !selectedAccountId || !selectedAccount) return null;
    const date = String(selectedAccount.opening_balance_date ?? "").slice(0, 10);
    if (!date || date.length !== 10) return null;

    return {
      id: "opening_balance",
      business_id: selectedBusinessId,
      account_id: selectedAccountId,
      date,
      payee: "Opening Balance",
      memo: selectedAccount.name ?? null,
      amount_cents: String(Number(selectedAccount.opening_balance_cents ?? 0)),
      type: "OPENING",
      method: null,
      status: "SYSTEM",
      deleted_at: null,
      created_at: date + "T00:00:00.000Z",
      updated_at: date + "T00:00:00.000Z",
    };
  }, [selectedBusinessId, selectedAccountId, selectedAccount]);

  const entriesSorted = useMemo(() => {
    const list = (entriesQ.data ?? []).slice();
    list.sort(sortEntriesDisplayDesc);
    return list;
  }, [entriesQ.data]);

  const entriesWithOpening = useMemo(() => {
    if (!openingEntry) return entriesSorted;
    const list = entriesSorted.slice();
    if (!list.some((e) => e.id === "opening_balance")) list.push(openingEntry);
    list.sort(sortEntriesDisplayDesc);
    return list;
  }, [entriesSorted, openingEntry]);

  const payeeOptions = useMemo(() => {
    const set = new Set<string>();
    for (const e of entriesWithOpening) {
      const p = (e.payee || "").trim();
      if (p && p !== "Opening Balance") set.add(p);
    }
    return Array.from(set);
  }, [entriesWithOpening]);

  const categoryOptions = useMemo(() => {
    const set = new Set<string>();
    for (const e of entriesWithOpening) {
      const c = (e.memo || "").trim();
      if (c && c !== (selectedAccount?.name ?? "")) set.add(c);
    }
    return Array.from(set);
  }, [entriesWithOpening, selectedAccount?.name]);

  // running balance
  const rowModels = useMemo(() => {
    const listDesc = entriesWithOpening.slice();
    const listAsc = entriesWithOpening.slice().sort(sortEntriesChronAsc);
    const idxOpen = listAsc.findIndex((e) => e.id === "opening_balance");

    const delta = listAsc.map((e) => (e.id === "opening_balance" ? 0n : toBigIntSafe(e.amount_cents)));
    const bal = new Array<bigint>(listAsc.length).fill(0n);

    if (idxOpen >= 0) {
      bal[idxOpen] = openingBalanceCents;
      for (let i = idxOpen + 1; i < listAsc.length; i++) bal[i] = bal[i - 1] + delta[i];
      for (let i = idxOpen - 1; i >= 0; i--) bal[i] = bal[i + 1] - delta[i + 1];
    } else {
      for (let i = 0; i < listAsc.length; i++) bal[i] = (i === 0 ? 0n : bal[i - 1]) + delta[i];
    }

    const balById = new Map<string, bigint>();
    for (let i = 0; i < listAsc.length; i++) balById.set(listAsc[i].id, bal[i]);

    return listDesc.map((e) => {
      const amt = toBigIntSafe(e.amount_cents);
      const rowBal = balById.get(e.id) ?? 0n;
      return {
        id: e.id,
        date: e.date,
        ref: "",
        payee: e.payee ?? "",
        typeDisplay: titleCase(e.type ?? ""),
        methodDisplay: titleCase(e.method ?? ""),
        category: (e.memo ?? "") || "",
        amountStr: formatUsdFromCents(amt),
        amountNeg: amt < 0n,
        balanceStr: formatUsdFromCents(rowBal),
        balanceNeg: rowBal < 0n,
        status: titleCase(e.status ?? ""),
        canDelete: e.id !== "opening_balance",
      };
    });
  }, [entriesWithOpening, openingBalanceCents]);

  const [searchPayee, setSearchPayee] = useState("");
  const filteredRowsAll = useMemo(() => {
    const q = searchPayee.trim().toLowerCase();
    if (!q) return rowModels;
    return rowModels.filter((r) => r.payee.toLowerCase().includes(q));
  }, [rowModels, searchPayee]);

  const startIdx = (page - 1) * rowsPerPage;
  const endIdx = page * rowsPerPage;
  const pageRows = filteredRowsAll.slice(startIdx, endIdx);

  const hasMoreOnServer = (entriesQ.data?.length ?? 0) === fetchLimit && fetchLimit < maxFetch;
  const canNext = endIdx < filteredRowsAll.length || hasMoreOnServer;
  const canPrev = page > 1;
  const totalPages = Math.max(1, Math.ceil(filteredRowsAll.length / rowsPerPage));

  // selection
  const checkboxClass =
    "h-4 w-4 rounded border border-slate-300 bg-white checked:bg-slate-900 checked:border-slate-900";
  const [selectedIds, setSelectedIds] = useState<Record<string, boolean>>({});
  const allPageSelected = useMemo(() => {
    const ids = pageRows.filter((r) => r.id !== "opening_balance").map((r) => r.id);
    if (ids.length === 0) return false;
    return ids.every((id) => !!selectedIds[id]);
  }, [pageRows, selectedIds]);
  function toggleRow(id: string) { setSelectedIds((m) => ({ ...m, [id]: !m[id] })); }
  function toggleAllPage() {
    const ids = pageRows.filter((r) => r.id !== "opening_balance").map((r) => r.id);
    const next = { ...selectedIds };
    const shouldSelect = !allPageSelected;
    for (const id of ids) next[id] = shouldSelect;
    setSelectedIds(next);
  }

  // add row state + refs (FIX payee required bug)
  const [draftDate, setDraftDate] = useState(todayYmd());
  const [draftRef, setDraftRef] = useState("");
  const [draftPayee, setDraftPayee] = useState("");
  const [draftType, setDraftType] = useState<UiType>("EXPENSE");
  const [draftMethod, setDraftMethod] = useState<UiMethod>("CASH");
  const [draftCategory, setDraftCategory] = useState("");
  const [draftAmount, setDraftAmount] = useState("0.00");
  const [err, setErr] = useState<string | null>(null);

  const payeeInputRef = useRef<HTMLInputElement>(null);
  const amountInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (!authReady) return;
    requestAnimationFrame(() => payeeInputRef.current?.focus());
  }, [authReady]);

  // clear error as user edits
  useEffect(() => { if (err) setErr(null); }, [draftPayee, draftAmount, draftCategory, draftRef, draftDate, draftType, draftMethod]);

  const [typeOpen, setTypeOpen] = useState(false);
  const [methodOpen, setMethodOpen] = useState(false);

  // robust submit reads actual input values (no stale state)
  function readSubmitValues() {
    const payee = (payeeInputRef.current?.value ?? draftPayee).trim();
    const amountStr = (amountInputRef.current?.value ?? draftAmount).trim();
    const centsAbs = Math.abs(parseMoneyToCents(amountStr));
    return { payee, amountStr, centsAbs };
  }

  const createMut = useMutation({
    mutationFn: async (vars: CreateVars) => {
      if (!selectedBusinessId || !selectedAccountId) throw new Error("Missing business/account");

      const centsAbs = Math.abs(parseMoneyToCents(vars.amountStr));
      if (!vars.payee.trim()) throw new Error("Payee is required");
      if (centsAbs === 0) throw new Error("Amount is required");

      const cents = parseMoneyToCents(vars.amountStr);
      const backendType = normalizeBackendType(vars.type);
      const signed = backendType === "EXPENSE" ? -Math.abs(cents) : Math.abs(cents);

      return createEntry({
        businessId: selectedBusinessId,
        accountId: selectedAccountId,
        input: {
          date: vars.date,
          payee: vars.payee.trim(),
          memo: (vars.category || "").trim() || undefined,
          amount_cents: signed,
          type: backendType,
          method: normalizeBackendMethod(vars.method),
          status: "EXPECTED",
        },
      });
    },

    onMutate: async (vars: CreateVars) => {
      const start = performance.now();
      setErr(null);

      await qc.cancelQueries({ queryKey: entriesKey });
      const previous = (qc.getQueryData(entriesKey) as Entry[] | undefined) ?? [];
      const nowIso = new Date().toISOString();

      const cents = parseMoneyToCents(vars.amountStr);
      const backendType = normalizeBackendType(vars.type);
      const signed = backendType === "EXPENSE" ? -Math.abs(cents) : Math.abs(cents);

      const optimistic: Entry = {
        id: vars.tempId,
        business_id: selectedBusinessId!,
        account_id: selectedAccountId!,
        date: vars.date,
        payee: vars.payee.trim(),
        memo: (vars.category || "").trim() || null,
        amount_cents: String(signed),
        type: backendType,
        method: normalizeBackendMethod(vars.method),
        status: "EXPECTED",
        deleted_at: null,
        created_at: nowIso,
        updated_at: nowIso,
      };

      qc.setQueryData(entriesKey, [optimistic, ...previous]);
      metrics.timeUi("createEntry click->row", start);

      // reset but keep date
      setDraftRef("");
      setDraftPayee("");
      setDraftCategory("");
      setDraftAmount("0.00");
      setDraftType("EXPENSE");
      setDraftMethod("CASH");

      requestAnimationFrame(() => payeeInputRef.current?.focus());

      return { previous, tempId: vars.tempId };
    },

    onError: (e: any, _vars, ctx: any) => {
      if (ctx?.previous) qc.setQueryData(entriesKey, ctx.previous);
      setErr(e?.message || "Create failed");
    },

    onSuccess: async (serverEntry, vars) => {
      const current = (qc.getQueryData(entriesKey) as Entry[] | undefined) ?? [];
      qc.setQueryData(entriesKey, current.map((e) => (e.id === vars.tempId ? serverEntry : e)));
      await qc.invalidateQueries({ queryKey: ["ledgerSummary", selectedBusinessId, selectedAccountId, from, to] });
    },
  });

  const deleteMut = useMutation({
    mutationFn: async (entryId: string) => {
      if (!selectedBusinessId || !selectedAccountId) throw new Error("Missing business/account");
      return deleteEntry({ businessId: selectedBusinessId, accountId: selectedAccountId, entryId });
    },
    onMutate: async (entryId: string) => {
      const start = performance.now();
      await qc.cancelQueries({ queryKey: entriesKey });
      const previous = (qc.getQueryData(entriesKey) as Entry[] | undefined) ?? [];
      qc.setQueryData(entriesKey, previous.filter((e) => e.id !== entryId));
      metrics.timeUi("deleteEntry click->rowRemoved", start);
      return { previous };
    },
    onError: (_e: any, _id, ctx: any) => {
      if (ctx?.previous) qc.setQueryData(entriesKey, ctx.previous);
    },
    onSuccess: async () => {
      await qc.invalidateQueries({ queryKey: ["ledgerSummary", selectedBusinessId, selectedAccountId, from, to] });
    },
  });

  function submitInline() {
    const { payee, amountStr, centsAbs } = readSubmitValues();
    if (!payee) { setErr("Payee is required"); return; }
    if (centsAbs === 0) { setErr("Amount is required"); return; }
    if (createMut.isPending) return;

    createMut.mutate({
      tempId: `temp_${Date.now()}`,
      date: draftDate,
      ref: draftRef,
      payee,
      type: draftType,
      method: draftMethod,
      category: draftCategory,
      amountStr,
    });
  }

  const accountCapsule = (
    <CapsuleSelect
      loading={accountsQ.isLoading}
      value={selectedAccountId || ""}
      onValueChange={(v) => {
        setPage(1);
        router.replace(`/ledger?businessId=${selectedBusinessId}&accountId=${v}`);
      }}
      options={(accountsQ.data ?? []).filter((a) => !a.archived_at).map((a) => ({ value: a.id, label: a.name }))}
      placeholder="Select account"
    />
  );

  if (!authReady) return <Skeleton className="h-10 w-64" />;

  // Widen Type + Method so "Adjustment" fits and Method matches
  const cols = [
    <col key="c0" style={{ width: "32px" }} />,
    <col key="c1" style={{ width: "110px" }} />,
    <col key="c2" style={{ width: "70px" }} />,
    <col key="c3" />,
    <col key="c4" style={{ width: "150px" }} />, // Type wider
    <col key="c5" style={{ width: "150px" }} />, // Method same
    <col key="c6" style={{ width: "160px" }} />,
    <col key="c7" style={{ width: "130px" }} />,
    <col key="c8" style={{ width: "130px" }} />,
    <col key="c9" style={{ width: "90px" }} />,
    <col key="c10" style={{ width: "90px" }} />,
  ];

  // Make rows thinner; opening balance row already looks right
  const th = "px-2 py-0.5 align-middle text-xs font-semibold uppercase tracking-wide text-slate-600";
  const td = "px-2 py-0.5 align-middle text-xs";
  const trunc = "truncate overflow-hidden whitespace-nowrap";
  const num = "text-right tabular-nums tracking-tight";
  const center = "text-center";

  const headerRow = (
    <tr className="h-[28px] border-b border-slate-200 bg-slate-50">
      <th className={th}>
        <input type="checkbox" checked={allPageSelected} onChange={toggleAllPage} className={checkboxClass} />
      </th>
      <th className={th}>Date</th>
      <th className={th}>Ref</th>
      <th className={th}>Payee</th>
      <th className={th}>Type</th>
      <th className={th}>Method</th>
      <th className={th}>Category</th>
      <th className={th + " " + num}>Amount</th>
      <th className={th + " " + num}>Balance</th>
      <th className={th + " " + center}>Status</th>
      <th className={th + " text-right"}>Actions</th>
    </tr>
  );

  const selectTriggerClass = "h-7 w-full text-xs px-2 py-1 bg-white";
  const selectContentProps = { side: "bottom" as const, align: "start" as const };

  const addRow = (
    <tr className="bg-emerald-50 border-b-2 border-emerald-200">
      <td className={"bg-emerald-50 " + td}></td>

      <td className={"bg-emerald-50 " + td}>
        <input
          className="h-7 w-full text-xs px-1 bg-transparent border-0 border-b border-emerald-300/70 focus:outline-none focus:border-emerald-600"
          type="date"
          value={draftDate}
          onChange={(e) => setDraftDate(e.target.value)}
        />
      </td>

      <td className={"bg-emerald-50 " + td}>
        <input
          className="h-7 w-full text-xs px-1 bg-transparent border-0 border-b border-emerald-300/70 focus:outline-none focus:border-emerald-600"
          placeholder="Ref"
          value={draftRef}
          onChange={(e) => setDraftRef(e.target.value)}
          maxLength={32}
          onKeyDown={(e) => { if (e.key === "Enter") submitInline(); }}
        />
      </td>

      <td className={"bg-emerald-50 " + td}>
        <AutoInput
          value={draftPayee}
          onValueChange={setDraftPayee}
          options={payeeOptions}
          placeholder="Payee"
          inputRef={payeeInputRef}
          inputClassName="h-7 w-full text-xs px-1 bg-transparent border-0 border-b border-emerald-300/70 focus:outline-none focus:border-emerald-600"
          onSubmit={submitInline}
        />
      </td>

      <td className={"bg-emerald-50 " + td}>
        <Select open={typeOpen} onOpenChange={setTypeOpen} value={draftType} onValueChange={(v) => setDraftType(v as UiType)}>
          <SelectTrigger
            className={selectTriggerClass}
            onKeyDown={(e) => {
              if (e.key === "ArrowDown" || e.key === "ArrowUp") { e.preventDefault(); setTypeOpen(true); }
              if (e.key === "Enter" && !typeOpen) { e.preventDefault(); submitInline(); }
            }}
          >
            <SelectValue />
          </SelectTrigger>
          <SelectContent {...selectContentProps}>
            <SelectItem value="INCOME">Income</SelectItem>
            <SelectItem value="EXPENSE">Expense</SelectItem>
            <SelectItem value="TRANSFER">Transfer</SelectItem>
            <SelectItem value="ADJUSTMENT">Adjustment</SelectItem>
          </SelectContent>
        </Select>
      </td>

      <td className={"bg-emerald-50 " + td}>
        <Select open={methodOpen} onOpenChange={setMethodOpen} value={draftMethod} onValueChange={(v) => setDraftMethod(v as UiMethod)}>
          <SelectTrigger
            className={selectTriggerClass}
            onKeyDown={(e) => {
              if (e.key === "ArrowDown" || e.key === "ArrowUp") { e.preventDefault(); setMethodOpen(true); }
              if (e.key === "Enter" && !methodOpen) { e.preventDefault(); submitInline(); }
            }}
          >
            <SelectValue />
          </SelectTrigger>
          <SelectContent {...selectContentProps}>
            <SelectItem value="CASH">Cash</SelectItem>
            <SelectItem value="CARD">Card</SelectItem>
            <SelectItem value="ACH">ACH</SelectItem>
            <SelectItem value="WIRE">Wire</SelectItem>
            <SelectItem value="CHECK">Check</SelectItem>
            <SelectItem value="DIRECT_DEPOSIT">DD (Direct Deposit)</SelectItem>
            <SelectItem value="ZELLE">Zelle</SelectItem>
            <SelectItem value="TRANSFER">Transfer</SelectItem>
            <SelectItem value="OTHER">Other</SelectItem>
          </SelectContent>
        </Select>
      </td>

      <td className={"bg-emerald-50 " + td}>
        <AutoInput
          value={draftCategory}
          onValueChange={setDraftCategory}
          options={categoryOptions}
          placeholder="Category"
          inputClassName="h-7 w-full text-xs px-2 bg-white rounded-md border border-slate-200"
          onSubmit={submitInline}
        />
      </td>

      <td className={"bg-emerald-50 " + td + " " + num}>
        <input
          ref={amountInputRef}
          className="h-7 w-full text-xs px-2 text-right bg-white rounded-md border border-slate-200 tabular-nums"
          placeholder="0.00"
          value={draftAmount}
          onChange={(e) => setDraftAmount(e.target.value)}
          onKeyDown={(e) => { if (e.key === "Enter") submitInline(); }}
          onFocus={(e) => e.currentTarget.select()}
        />
      </td>

      <td className={"bg-emerald-50 " + td + " " + num + " text-slate-400"}>—</td>
      <td className={"bg-emerald-50 " + td + " " + center}></td>

      <td className={"bg-emerald-50 " + td + " text-right"}>
        <Button className="h-7 px-3 text-xs" disabled={createMut.isPending} onClick={submitInline}>
          Add
        </Button>
      </td>
    </tr>
  );

  const body = entriesQ.isLoading ? (
    <tr><td className="p-6 text-slate-500" colSpan={11}>Loading…</td></tr>
  ) : (
    pageRows.map((r) => (
      <tr key={r.id} className="h-[24px] border-b border-slate-200 hover:bg-slate-50">
        <td className={td}>
          {r.id !== "opening_balance" ? (
            <input type="checkbox" checked={!!selectedIds[r.id]} onChange={() => toggleRow(r.id)} className={checkboxClass} />
          ) : null}
        </td>

        <td className={td + " " + trunc}>{r.date}</td>
        <td className={td + " " + trunc + " text-slate-500"}>{r.ref}</td>
        <td className={td + " " + trunc + " font-medium"}>{r.payee}</td>
        <td className={td + " " + trunc}>{r.typeDisplay}</td>
        <td className={td + " " + trunc}>{r.methodDisplay}</td>
        <td className={td + " " + trunc}>{r.category}</td>

        <td className={td + " " + num + (r.amountNeg ? " text-red-600 font-semibold" : " font-semibold")}>{r.amountStr}</td>
        <td className={td + " " + num + (r.balanceNeg ? " text-red-600" : "")}>{r.balanceStr}</td>

        <td className={td + " " + center}>{r.status}</td>

        <td className={td + " text-right"}>
          {r.canDelete ? (
            <Button
              variant="outline"
              className="h-6 px-2 text-xs"
              disabled={deleteMut.isPending}
              onClick={() => {
                const ok = window.confirm("Delete this entry?");
                if (!ok) return;
                deleteMut.mutate(r.id);
              }}
            >
              Delete
            </Button>
          ) : null}
        </td>
      </tr>
    ))
  );

  return (
    <div className="flex flex-col gap-3 overflow-hidden" style={containerStyle}>
      <PageHeader title="Ledger" subtitle="Account-scoped" inlineAfterTitle={accountCapsule} />

      <FilterBar
        searchValue={searchPayee}
        onSearchChange={setSearchPayee}
        onReset={() => setSearchPayee("")}
        right={err ? <div className="text-sm text-red-600">{err}</div> : null}
      />

      <LedgerTableShell
        colgroup={cols}
        header={headerRow}
        addRow={addRow}
        body={body}
        footer={
          <tr>
            <td colSpan={11} className="p-0">
              <TotalsFooter
                rowsPerPage={rowsPerPage}
                setRowsPerPage={setRowsPerPage}
                page={page}
                setPage={setPage}
                totalPages={totalPages}
                canPrev={canPrev}
                canNext={canNext}
                incomeText={summaryQ.isLoading ? "…" : formatUsdFromCents(toBigIntSafe(summaryQ.data?.totals?.income_cents))}
                expenseText={summaryQ.isLoading ? "…" : formatUsdFromCents(toBigIntSafe(summaryQ.data?.totals?.expense_cents))}
                netText={summaryQ.isLoading ? "…" : formatUsdFromCents(toBigIntSafe(summaryQ.data?.totals?.net_cents))}
                balanceText={summaryQ.isLoading ? "…" : formatUsdFromCents(toBigIntSafe(summaryQ.data?.balance_cents))}
              />
            </td>
          </tr>
        }
      />
    </div>
  );
}
